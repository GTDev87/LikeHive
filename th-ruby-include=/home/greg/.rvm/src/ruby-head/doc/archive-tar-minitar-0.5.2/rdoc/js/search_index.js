var search_data = {"index":{"searchIndex":["archive","tar","minitar","blockrequired","closedstream","command","commandcreate","commandextract","commandhelp","commandlist","commandpattern","abstractcommanderror","commandalreadyexists","unknowncommanderror","progressbar","filenametoolong","input","nonseekablestream","output","reader","entrystream","invalidentrystream","unexpectedeof","writer","boundedstream","fileoverflow","restrictedstream","posixheader","<<()","[]()","[]()","add()","add_file()","add_file_simple()","altname()","altname()","altname()","bytes_read()","call()","call()","call()","call()","call()","close()","close()","close()","close()","close()","command()","command?()","default_ioe()","dir?()","directory()","directory?()","each()","each()","each_entry()","empty?()","eof?()","extract_entry()","file()","file?()","file_transfer_mode()","finish()","flush()","format=()","format_arguments=()","full_name()","getc()","getc()","halt()","help()","help()","help()","help()","help()","inc()","inspect()","mkdir()","modestr()","name()","name()","name()","name()","name()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new_from_stream()","open()","open()","open()","open()","open()","pack()","pack_file()","pos()","read()","read()","rewind()","rewind()","rewind()","run()","set()","tar()","tar()","to_s()","unpack()","update_checksum()","write()","write()","changelog","install","readme"],"longSearchIndex":["archive","archive::tar","archive::tar::minitar","archive::tar::minitar::blockrequired","archive::tar::minitar::closedstream","archive::tar::minitar::command","archive::tar::minitar::command::commandcreate","archive::tar::minitar::command::commandextract","archive::tar::minitar::command::commandhelp","archive::tar::minitar::command::commandlist","archive::tar::minitar::command::commandpattern","archive::tar::minitar::command::commandpattern::abstractcommanderror","archive::tar::minitar::command::commandpattern::commandalreadyexists","archive::tar::minitar::command::commandpattern::unknowncommanderror","archive::tar::minitar::command::progressbar","archive::tar::minitar::filenametoolong","archive::tar::minitar::input","archive::tar::minitar::nonseekablestream","archive::tar::minitar::output","archive::tar::minitar::reader","archive::tar::minitar::reader::entrystream","archive::tar::minitar::reader::invalidentrystream","archive::tar::minitar::unexpectedeof","archive::tar::minitar::writer","archive::tar::minitar::writer::boundedstream","archive::tar::minitar::writer::boundedstream::fileoverflow","archive::tar::minitar::writer::restrictedstream","archive::tar::posixheader","archive::tar::minitar::command::commandpattern::<<()","archive::tar::minitar::command::commandpattern#[]()","archive::tar::minitar::command::commandpattern::[]()","archive::tar::minitar::command::commandpattern::add()","archive::tar::minitar::writer#add_file()","archive::tar::minitar::writer#add_file_simple()","archive::tar::minitar::command::commandcreate#altname()","archive::tar::minitar::command::commandextract#altname()","archive::tar::minitar::command::commandlist#altname()","archive::tar::minitar::reader::entrystream#bytes_read()","archive::tar::minitar::command::commandcreate#call()","archive::tar::minitar::command::commandextract#call()","archive::tar::minitar::command::commandhelp#call()","archive::tar::minitar::command::commandlist#call()","archive::tar::minitar::command::commandpattern#call()","archive::tar::minitar::input#close()","archive::tar::minitar::output#close()","archive::tar::minitar::reader#close()","archive::tar::minitar::reader::entrystream#close()","archive::tar::minitar::writer#close()","archive::tar::minitar::command::commandpattern::command()","archive::tar::minitar::command::commandpattern::command?()","archive::tar::minitar::command::commandpattern::default_ioe()","archive::tar::minitar::dir?()","archive::tar::minitar::reader::entrystream#directory()","archive::tar::minitar::reader::entrystream#directory?()","archive::tar::minitar::input#each()","archive::tar::minitar::reader#each()","archive::tar::minitar::reader#each_entry()","archive::tar::posixheader#empty?()","archive::tar::minitar::reader::entrystream#eof?()","archive::tar::minitar::input#extract_entry()","archive::tar::minitar::reader::entrystream#file()","archive::tar::minitar::reader::entrystream#file?()","archive::tar::minitar::command::progressbar#file_transfer_mode()","archive::tar::minitar::command::progressbar#finish()","archive::tar::minitar::writer#flush()","archive::tar::minitar::command::progressbar#format=()","archive::tar::minitar::command::progressbar#format_arguments=()","archive::tar::minitar::reader::entrystream#full_name()","archive::tar::minitar::reader::entrystream#getc()","archive::tar::minitar::reader::invalidentrystream#getc()","archive::tar::minitar::command::progressbar#halt()","archive::tar::minitar::command::commandcreate#help()","archive::tar::minitar::command::commandextract#help()","archive::tar::minitar::command::commandhelp#help()","archive::tar::minitar::command::commandlist#help()","archive::tar::minitar::command::commandpattern#help()","archive::tar::minitar::command::progressbar#inc()","archive::tar::minitar::command::progressbar#inspect()","archive::tar::minitar::writer#mkdir()","archive::tar::minitar::command::commandlist#modestr()","archive::tar::minitar::command::commandcreate#name()","archive::tar::minitar::command::commandextract#name()","archive::tar::minitar::command::commandhelp#name()","archive::tar::minitar::command::commandlist#name()","archive::tar::minitar::command::commandpattern#name()","archive::tar::minitar::command::progressbar::new()","archive::tar::minitar::input::new()","archive::tar::minitar::output::new()","archive::tar::minitar::reader::new()","archive::tar::minitar::reader::entrystream::new()","archive::tar::minitar::writer::new()","archive::tar::minitar::writer::boundedstream::new()","archive::tar::minitar::writer::restrictedstream::new()","archive::tar::posixheader::new()","archive::tar::posixheader::new_from_stream()","archive::tar::minitar::open()","archive::tar::minitar::input::open()","archive::tar::minitar::output::open()","archive::tar::minitar::reader::open()","archive::tar::minitar::writer::open()","archive::tar::minitar::pack()","archive::tar::minitar::pack_file()","archive::tar::minitar::reader::entrystream#pos()","archive::tar::minitar::reader::entrystream#read()","archive::tar::minitar::reader::invalidentrystream#read()","archive::tar::minitar::reader#rewind()","archive::tar::minitar::reader::entrystream#rewind()","archive::tar::minitar::reader::invalidentrystream#rewind()","archive::tar::minitar::command::run()","archive::tar::minitar::command::progressbar#set()","archive::tar::minitar::input#tar()","archive::tar::minitar::output#tar()","archive::tar::posixheader#to_s()","archive::tar::minitar::unpack()","archive::tar::posixheader#update_checksum()","archive::tar::minitar::writer::boundedstream#write()","archive::tar::minitar::writer::restrictedstream#write()","","",""],"info":[["Archive","","Archive.html","",""],["Archive::Tar","","Archive/Tar.html","",""],["Archive::Tar::Minitar","","Archive/Tar/Minitar.html","","<p>Archive::Tar::Minitar 0.5.2\n<p>Archive::Tar::Minitar is a pure-Ruby library and command-line utility that\n…\n"],["Archive::Tar::Minitar::BlockRequired","","Archive/Tar/Minitar/BlockRequired.html","","<p>The exception raised when a block is required for proper operation of the\nmethod.\n"],["Archive::Tar::Minitar::ClosedStream","","Archive/Tar/Minitar/ClosedStream.html","","<p>The exception raised when operations are performed on a stream that has\npreviously been closed.\n"],["Archive::Tar::Minitar::Command","","Archive/Tar/Minitar/Command.html","",""],["Archive::Tar::Minitar::Command::CommandCreate","","Archive/Tar/Minitar/Command/CommandCreate.html","",""],["Archive::Tar::Minitar::Command::CommandExtract","","Archive/Tar/Minitar/Command/CommandExtract.html","",""],["Archive::Tar::Minitar::Command::CommandHelp","","Archive/Tar/Minitar/Command/CommandHelp.html","",""],["Archive::Tar::Minitar::Command::CommandList","","Archive/Tar/Minitar/Command/CommandList.html","",""],["Archive::Tar::Minitar::Command::CommandPattern","","Archive/Tar/Minitar/Command/CommandPattern.html","",""],["Archive::Tar::Minitar::Command::CommandPattern::AbstractCommandError","","Archive/Tar/Minitar/Command/CommandPattern/AbstractCommandError.html","",""],["Archive::Tar::Minitar::Command::CommandPattern::CommandAlreadyExists","","Archive/Tar/Minitar/Command/CommandPattern/CommandAlreadyExists.html","",""],["Archive::Tar::Minitar::Command::CommandPattern::UnknownCommandError","","Archive/Tar/Minitar/Command/CommandPattern/UnknownCommandError.html","",""],["Archive::Tar::Minitar::Command::ProgressBar","","Archive/Tar/Minitar/Command/ProgressBar.html","",""],["Archive::Tar::Minitar::FileNameTooLong","","Archive/Tar/Minitar/FileNameTooLong.html","","<p>The exception raised when a filename exceeds 256 bytes in length, the\nmaximum supported by the standard …\n"],["Archive::Tar::Minitar::Input","","Archive/Tar/Minitar/Input.html","","<p>Wraps a Archive::Tar::Minitar::Reader with convenience methods and wrapped\nstream management; Input only …\n"],["Archive::Tar::Minitar::NonSeekableStream","","Archive/Tar/Minitar/NonSeekableStream.html","","<p>The exception raised when a wrapped data stream class is expected to\nrespond to #rewind or #pos but does …\n"],["Archive::Tar::Minitar::Output","","Archive/Tar/Minitar/Output.html","","<p>Wraps a Archive::Tar::Minitar::Writer with convenience methods and wrapped\nstream management; Output …\n"],["Archive::Tar::Minitar::Reader","","Archive/Tar/Minitar/Reader.html","","<p>The class that reads a tar format archive from a data stream. The data\nstream may be sequential or random …\n"],["Archive::Tar::Minitar::Reader::EntryStream","","Archive/Tar/Minitar/Reader/EntryStream.html","","<p>EntryStreams are pseudo-streams on top of the main data stream.\n"],["Archive::Tar::Minitar::Reader::InvalidEntryStream","","Archive/Tar/Minitar/Reader/InvalidEntryStream.html","","<p>This marks the EntryStream closed for reading without closing the actual\ndata stream.\n"],["Archive::Tar::Minitar::UnexpectedEOF","","Archive/Tar/Minitar/UnexpectedEOF.html","","<p>The exception raised when a data stream ends before the amount of data\nexpected in the archive’s PosixHeader …\n"],["Archive::Tar::Minitar::Writer","","Archive/Tar/Minitar/Writer.html","","<p>The class that writes a tar format archive to a data stream.\n"],["Archive::Tar::Minitar::Writer::BoundedStream","","Archive/Tar/Minitar/Writer/BoundedStream.html","","<p>A RestrictedStream that also has a size limit.\n"],["Archive::Tar::Minitar::Writer::BoundedStream::FileOverflow","","Archive/Tar/Minitar/Writer/BoundedStream/FileOverflow.html","","<p>The exception raised when the user attempts to write more data to a\nBoundedStream than has been allocated. …\n"],["Archive::Tar::Minitar::Writer::RestrictedStream","","Archive/Tar/Minitar/Writer/RestrictedStream.html","","<p>A stream wrapper that can only be written to. Any attempt to read from this\nrestricted stream will result …\n"],["Archive::Tar::PosixHeader","","Archive/Tar/PosixHeader.html","","<p>Archive::Tar::PosixHeader\n<p>Implements the POSIX tar header as a Ruby class. The structure of the POSIX\n…\n"],["<<","Archive::Tar::Minitar::Command::CommandPattern","Archive/Tar/Minitar/Command/CommandPattern.html#method-c-3C-3C","(command)",""],["[]","Archive::Tar::Minitar::Command::CommandPattern","Archive/Tar/Minitar/Command/CommandPattern.html#method-i-5B-5D","(args, opts = {}, ioe = {})",""],["[]","Archive::Tar::Minitar::Command::CommandPattern","Archive/Tar/Minitar/Command/CommandPattern.html#method-c-5B-5D","(cmd)",""],["add","Archive::Tar::Minitar::Command::CommandPattern","Archive/Tar/Minitar/Command/CommandPattern.html#method-c-add","(command)",""],["add_file","Archive::Tar::Minitar::Writer","Archive/Tar/Minitar/Writer.html#method-i-add_file","(name, opts = {})","<p>Adds a file to the archive as <code>name</code>. <code>opts</code> must\ncontain the following value:\n<p>:mode &mdash; The Unix file permissions …\n\n"],["add_file_simple","Archive::Tar::Minitar::Writer","Archive/Tar/Minitar/Writer.html#method-i-add_file_simple","(name, opts = {})","<p>Adds a file to the archive as <code>name</code>. <code>opts</code> must\ncontain the following values:\n<p>:mode &mdash; The Unix file permissions …\n"],["altname","Archive::Tar::Minitar::Command::CommandCreate","Archive/Tar/Minitar/Command/CommandCreate.html#method-i-altname","()",""],["altname","Archive::Tar::Minitar::Command::CommandExtract","Archive/Tar/Minitar/Command/CommandExtract.html#method-i-altname","()",""],["altname","Archive::Tar::Minitar::Command::CommandList","Archive/Tar/Minitar/Command/CommandList.html#method-i-altname","()",""],["bytes_read","Archive::Tar::Minitar::Reader::EntryStream","Archive/Tar/Minitar/Reader/EntryStream.html#method-i-bytes_read","()",""],["call","Archive::Tar::Minitar::Command::CommandCreate","Archive/Tar/Minitar/Command/CommandCreate.html#method-i-call","(args, opts = {}, ioe = {})",""],["call","Archive::Tar::Minitar::Command::CommandExtract","Archive/Tar/Minitar/Command/CommandExtract.html#method-i-call","(args, opts = {}, ioe = {})",""],["call","Archive::Tar::Minitar::Command::CommandHelp","Archive/Tar/Minitar/Command/CommandHelp.html#method-i-call","(args, opts = {}, ioe = {})",""],["call","Archive::Tar::Minitar::Command::CommandList","Archive/Tar/Minitar/Command/CommandList.html#method-i-call","(args, opts = {}, ioe = {})",""],["call","Archive::Tar::Minitar::Command::CommandPattern","Archive/Tar/Minitar/Command/CommandPattern.html#method-i-call","(args, opts = {}, ioe = {})",""],["close","Archive::Tar::Minitar::Input","Archive/Tar/Minitar/Input.html#method-i-close","()","<p>Closes the Reader object and the wrapped data stream.\n"],["close","Archive::Tar::Minitar::Output","Archive/Tar/Minitar/Output.html#method-i-close","()","<p>Closes the Writer object and the wrapped data stream.\n"],["close","Archive::Tar::Minitar::Reader","Archive/Tar/Minitar/Reader.html#method-i-close","()",""],["close","Archive::Tar::Minitar::Reader::EntryStream","Archive/Tar/Minitar/Reader/EntryStream.html#method-i-close","()","<p>Closes the entry.\n"],["close","Archive::Tar::Minitar::Writer","Archive/Tar/Minitar/Writer.html#method-i-close","()","<p>Closes the Writer.\n"],["command","Archive::Tar::Minitar::Command::CommandPattern","Archive/Tar/Minitar/Command/CommandPattern.html#method-c-command","(command)",""],["command?","Archive::Tar::Minitar::Command::CommandPattern","Archive/Tar/Minitar/Command/CommandPattern.html#method-c-command-3F","(command)",""],["default_ioe","Archive::Tar::Minitar::Command::CommandPattern","Archive/Tar/Minitar/Command/CommandPattern.html#method-c-default_ioe","(ioe = {})",""],["dir?","Archive::Tar::Minitar","Archive/Tar/Minitar.html#method-c-dir-3F","(path)","<p>Tests if <code>path</code> refers to a directory. Fixes an apparently\ncorrupted <code>stat()</code> call on Windows.\n"],["directory","Archive::Tar::Minitar::Reader::EntryStream","Archive/Tar/Minitar/Reader/EntryStream.html#method-i-directory","()",""],["directory?","Archive::Tar::Minitar::Reader::EntryStream","Archive/Tar/Minitar/Reader/EntryStream.html#method-i-directory-3F","()","<p>Returns <code>true</code> if the entry represents a directory.\n"],["each","Archive::Tar::Minitar::Input","Archive/Tar/Minitar/Input.html#method-i-each","(&block)","<p>Iterates through each entry and rewinds to the beginning of the stream when\nfinished.\n"],["each","Archive::Tar::Minitar::Reader","Archive/Tar/Minitar/Reader.html#method-i-each","(&block)","<p>Iterates through each entry in the data stream.\n"],["each_entry","Archive::Tar::Minitar::Reader","Archive/Tar/Minitar/Reader.html#method-i-each_entry","()","<p>Iterates through each entry in the data stream.\n"],["empty?","Archive::Tar::PosixHeader","Archive/Tar/PosixHeader.html#method-i-empty-3F","()",""],["eof?","Archive::Tar::Minitar::Reader::EntryStream","Archive/Tar/Minitar/Reader/EntryStream.html#method-i-eof-3F","()","<p>Returns <code>true</code> if the current read pointer is at the end of the\nEntryStream data.\n"],["extract_entry","Archive::Tar::Minitar::Input","Archive/Tar/Minitar/Input.html#method-i-extract_entry","(destdir, entry)","<p>Extracts the current <code>entry</code> to <code>destdir</code>. If a block\nis provided, it yields an <code>action</code> Symbol, the full name …\n"],["file","Archive::Tar::Minitar::Reader::EntryStream","Archive/Tar/Minitar/Reader/EntryStream.html#method-i-file","()",""],["file?","Archive::Tar::Minitar::Reader::EntryStream","Archive/Tar/Minitar/Reader/EntryStream.html#method-i-file-3F","()","<p>Returns <code>true</code> if the entry represents a plain file.\n"],["file_transfer_mode","Archive::Tar::Minitar::Command::ProgressBar","Archive/Tar/Minitar/Command/ProgressBar.html#method-i-file_transfer_mode","()",""],["finish","Archive::Tar::Minitar::Command::ProgressBar","Archive/Tar/Minitar/Command/ProgressBar.html#method-i-finish","()",""],["flush","Archive::Tar::Minitar::Writer","Archive/Tar/Minitar/Writer.html#method-i-flush","()","<p>Passes the #flush method to the wrapped stream, used for buffered streams.\n"],["format=","Archive::Tar::Minitar::Command::ProgressBar","Archive/Tar/Minitar/Command/ProgressBar.html#method-i-format-3D","(format)",""],["format_arguments=","Archive::Tar::Minitar::Command::ProgressBar","Archive/Tar/Minitar/Command/ProgressBar.html#method-i-format_arguments-3D","(arguments)",""],["full_name","Archive::Tar::Minitar::Reader::EntryStream","Archive/Tar/Minitar/Reader/EntryStream.html#method-i-full_name","()","<p>Returns the full and proper name of the entry.\n"],["getc","Archive::Tar::Minitar::Reader::EntryStream","Archive/Tar/Minitar/Reader/EntryStream.html#method-i-getc","()","<p>Reads one byte from the entry. Returns <code>nil</code> if there is no more\ndata to read.\n"],["getc","Archive::Tar::Minitar::Reader::InvalidEntryStream","Archive/Tar/Minitar/Reader/InvalidEntryStream.html#method-i-getc","()",""],["halt","Archive::Tar::Minitar::Command::ProgressBar","Archive/Tar/Minitar/Command/ProgressBar.html#method-i-halt","()",""],["help","Archive::Tar::Minitar::Command::CommandCreate","Archive/Tar/Minitar/Command/CommandCreate.html#method-i-help","()",""],["help","Archive::Tar::Minitar::Command::CommandExtract","Archive/Tar/Minitar/Command/CommandExtract.html#method-i-help","()",""],["help","Archive::Tar::Minitar::Command::CommandHelp","Archive/Tar/Minitar/Command/CommandHelp.html#method-i-help","()",""],["help","Archive::Tar::Minitar::Command::CommandList","Archive/Tar/Minitar/Command/CommandList.html#method-i-help","()",""],["help","Archive::Tar::Minitar::Command::CommandPattern","Archive/Tar/Minitar/Command/CommandPattern.html#method-i-help","()",""],["inc","Archive::Tar::Minitar::Command::ProgressBar","Archive/Tar/Minitar/Command/ProgressBar.html#method-i-inc","(step = 1)",""],["inspect","Archive::Tar::Minitar::Command::ProgressBar","Archive/Tar/Minitar/Command/ProgressBar.html#method-i-inspect","()",""],["mkdir","Archive::Tar::Minitar::Writer","Archive/Tar/Minitar/Writer.html#method-i-mkdir","(name, opts = {})","<p>Creates a directory in the tar.\n"],["modestr","Archive::Tar::Minitar::Command::CommandList","Archive/Tar/Minitar/Command/CommandList.html#method-i-modestr","(mode)",""],["name","Archive::Tar::Minitar::Command::CommandCreate","Archive/Tar/Minitar/Command/CommandCreate.html#method-i-name","()",""],["name","Archive::Tar::Minitar::Command::CommandExtract","Archive/Tar/Minitar/Command/CommandExtract.html#method-i-name","()",""],["name","Archive::Tar::Minitar::Command::CommandHelp","Archive/Tar/Minitar/Command/CommandHelp.html#method-i-name","()",""],["name","Archive::Tar::Minitar::Command::CommandList","Archive/Tar/Minitar/Command/CommandList.html#method-i-name","()",""],["name","Archive::Tar::Minitar::Command::CommandPattern","Archive/Tar/Minitar/Command/CommandPattern.html#method-i-name","()",""],["new","Archive::Tar::Minitar::Command::ProgressBar","Archive/Tar/Minitar/Command/ProgressBar.html#method-c-new","(title, total, out = STDERR)",""],["new","Archive::Tar::Minitar::Input","Archive/Tar/Minitar/Input.html#method-c-new","(input)","<p>Creates a new Input object. If <code>input</code> is a stream object that\nresponds to #read), then it will simply …\n"],["new","Archive::Tar::Minitar::Output","Archive/Tar/Minitar/Output.html#method-c-new","(output)","<p>Creates a new Output object. If <code>output</code> is a stream object that\nresponds to #read), then it will simply …\n"],["new","Archive::Tar::Minitar::Reader","Archive/Tar/Minitar/Reader.html#method-c-new","(anIO)","<p>Creates and returns a new Reader object.\n"],["new","Archive::Tar::Minitar::Reader::EntryStream","Archive/Tar/Minitar/Reader/EntryStream.html#method-c-new","(header, anIO)",""],["new","Archive::Tar::Minitar::Writer","Archive/Tar/Minitar/Writer.html#method-c-new","(anIO)","<p>Creates and returns a new Writer object.\n"],["new","Archive::Tar::Minitar::Writer::BoundedStream","Archive/Tar/Minitar/Writer/BoundedStream.html#method-c-new","(io, limit)",""],["new","Archive::Tar::Minitar::Writer::RestrictedStream","Archive/Tar/Minitar/Writer/RestrictedStream.html#method-c-new","(anIO)",""],["new","Archive::Tar::PosixHeader","Archive/Tar/PosixHeader.html#method-c-new","(vals)","<p>Creates a new PosixHeader. A PosixHeader cannot be created unless the\n#name, #size, #prefix, and #mode …\n"],["new_from_stream","Archive::Tar::PosixHeader","Archive/Tar/PosixHeader.html#method-c-new_from_stream","(stream)","<p>Creates a new PosixHeader from a data stream.\n"],["open","Archive::Tar::Minitar","Archive/Tar/Minitar.html#method-c-open","(dest, mode = \"r\", &block)","<p>A convenience method for wrapping Archive::Tar::Minitar::Input.open (mode\n<code>r</code>) and Archive::Tar::Minitar::Output.open …\n"],["open","Archive::Tar::Minitar::Input","Archive/Tar/Minitar/Input.html#method-c-open","(input)","<p>With no associated block, +Input::open+ is a synonym for +Input::new+. If\nthe optional code block is …\n"],["open","Archive::Tar::Minitar::Output","Archive/Tar/Minitar/Output.html#method-c-open","(output)","<p>With no associated block, +Output::open+ is a synonym for +Output::new+. If\nthe optional code block is …\n"],["open","Archive::Tar::Minitar::Reader","Archive/Tar/Minitar/Reader.html#method-c-open","(anIO)","<p>With no associated block, +Reader::open+ is a synonym for +Reader::new+. If\nthe optional code block is …\n"],["open","Archive::Tar::Minitar::Writer","Archive/Tar/Minitar/Writer.html#method-c-open","(anIO)","<p>With no associated block, +Writer::open+ is a synonym for +Writer::new+. If\nthe optional code block is …\n"],["pack","Archive::Tar::Minitar","Archive/Tar/Minitar.html#method-c-pack","(src, dest, recurse_dirs = true, &block)","<p>A convenience method to pack files specified by <code>src</code> into\n<code>dest</code>. If <code>src</code> is an Array, then each file detailed\n…\n"],["pack_file","Archive::Tar::Minitar","Archive/Tar/Minitar.html#method-c-pack_file","(entry, outputter)","<p>A convenience method to packs the file provided. <code>entry</code> may\neither be a filename (in which case various …\n"],["pos","Archive::Tar::Minitar::Reader::EntryStream","Archive/Tar/Minitar/Reader/EntryStream.html#method-i-pos","()","<p>Returns the current read pointer in the EntryStream.\n"],["read","Archive::Tar::Minitar::Reader::EntryStream","Archive/Tar/Minitar/Reader/EntryStream.html#method-i-read","(len = nil)","<p>Reads <code>len</code> bytes (or all remaining data) from the entry.\nReturns <code>nil</code> if there is no more data to read. …\n"],["read","Archive::Tar::Minitar::Reader::InvalidEntryStream","Archive/Tar/Minitar/Reader/InvalidEntryStream.html#method-i-read","(len = nil)",""],["rewind","Archive::Tar::Minitar::Reader","Archive/Tar/Minitar/Reader.html#method-i-rewind","()","<p>Resets the read pointer to the beginning of data stream. Do not call this\nduring a #each or #each_entry …\n"],["rewind","Archive::Tar::Minitar::Reader::EntryStream","Archive/Tar/Minitar/Reader/EntryStream.html#method-i-rewind","()","<p>Sets the current read pointer to the beginning of the EntryStream.\n"],["rewind","Archive::Tar::Minitar::Reader::InvalidEntryStream","Archive/Tar/Minitar/Reader/InvalidEntryStream.html#method-i-rewind","()",""],["run","Archive::Tar::Minitar::Command","Archive/Tar/Minitar/Command.html#method-c-run","(argv, input = $stdin, output = $stdout, error = $stderr)","<p>CommandPattern &lt;&lt; CommandAdd CommandPattern &lt;&lt; CommandDelete\n"],["set","Archive::Tar::Minitar::Command::ProgressBar","Archive/Tar/Minitar/Command/ProgressBar.html#method-i-set","(count)",""],["tar","Archive::Tar::Minitar::Input","Archive/Tar/Minitar/Input.html#method-i-tar","()","<p>Returns the Reader object for direct access.\n"],["tar","Archive::Tar::Minitar::Output","Archive/Tar/Minitar/Output.html#method-i-tar","()","<p>Returns the Writer object for direct access.\n"],["to_s","Archive::Tar::PosixHeader","Archive/Tar/PosixHeader.html#method-i-to_s","()",""],["unpack","Archive::Tar::Minitar","Archive/Tar/Minitar.html#method-c-unpack","(src, dest, files = [], &block)","<p>A convenience method to unpack files from <code>src</code> into the\ndirectory specified by <code>dest</code>. Only those files …\n"],["update_checksum","Archive::Tar::PosixHeader","Archive/Tar/PosixHeader.html#method-i-update_checksum","()","<p>Update the checksum field.\n"],["write","Archive::Tar::Minitar::Writer::BoundedStream","Archive/Tar/Minitar/Writer/BoundedStream.html#method-i-write","(data)",""],["write","Archive::Tar::Minitar::Writer::RestrictedStream","Archive/Tar/Minitar/Writer/RestrictedStream.html#method-i-write","(data)",""],["ChangeLog","","ChangeLog.html","","<p>Revision history for Ruby library Archive::Tar::Minitar. Unless explicitly\nnoted otherwise, all changes …\n"],["Install","","Install.html","","<p>Installing this package is as simple as:\n<p>% ruby install.rb\n<p>Alternatively, you can use the RubyGem version …\n"],["README","","README.html","","<p>Archive::Tar::Minitar README\n<p>\n<p>Archive::Tar::Minitar is a pure-Ruby library and command-line utility that\n…\n"]]}}